# ChronicleCapsules (Solidity)

**ChronicleCapsules** — маленький on-chain “архив тайм‑капсул” в формате **commit → time-lock → reveal**.
Вы создаёте капсулу с хэшем секрета (commit), опционально кладёте ETH, задаёте время разблокировки и бенефициара.
После наступления времени можно раскрыть секрет: контракт проверит соответствие хэшу и зафиксирует раскрытие событием.
Если был депозит, он станет доступен для вывода (pull-withdrawal), что безопаснее прямых переводов.

> Контракт написан без импортов и без сторонних библиотек — один файл, чтобы удобно заливать и читать.

---

## Возможности

- Создание капсулы: `commit`, `unlockTime`, `beneficiary`, опциональный `msg.value`
- Отмена капсулы до разблокировки (возврат депозита создателю через withdraw)
- Раскрытие секрета после времени разблокировки с проверкой commit-хэша
- Безопасный вывод ETH через `withdraw()` (pull payments)
- Небольшие “фишки” для гибкости:
  - `extendUnlockTime()` — создатель может **продлить** время (только вперёд, до наступления unlock)

---

## Быстрый старт без терминала (через Remix)

1. Откройте https://remix.ethereum.org
2. Создайте файл `ChronicleCapsules.sol` и вставьте код из `contracts/ChronicleCapsules.sol`
3. Вкладка **Solidity compiler**:
   - Version: `0.8.24` (или близкую `0.8.2x`)
   - Compile
4. Вкладка **Deploy & run**:
   - Environment: Remix VM (для теста) или Injected Provider (MetaMask)
   - Deploy

---

## Как пользоваться

### 1) Подготовить commit (хэш секрета)
Commit считается так:

- Берёте `salt` (bytes32, случайный)
- Берёте `payload` (bytes, например текст в UTF-8)
- Commit = `keccak256(abi.encode(salt, payload))`

В контракте есть helper:
- `computeCommit(bytes32 salt, bytes payload)`

> Важно: если вы раскроете `salt` и `payload` — это станет публичным в блокчейне (так и задумано).

### 2) Создать капсулу
Вызов:
- `createCapsule(commit, unlockTime, beneficiary)`  
и при желании отправьте ETH как `msg.value`.

- `unlockTime` должен быть **в будущем**
- `beneficiary` может быть `0x000...000` — тогда “получателем депозита” будет создатель

### 3) Отменить капсулу (до unlock)
- `cancelCapsule(capsuleId)`

Депозит не отправляется напрямую, а зачисляется в баланс вывода:
- потом вызовите `withdraw()`.

### 4) Раскрыть секрет (после unlock)
- `reveal(capsuleId, salt, payload)`

Если commit совпал:
- капсула помечается раскрытой
- эмитится событие с `payload`
- депозит (если был) зачисляется в withdraw-баланс бенефициара (или создателя, если beneficiary = 0)

### 5) Вывести ETH
- `withdraw()`

---

## Замечания по безопасности и ограничения

- Раскрытый `payload` навсегда публичен (в логах события и calldata).
- Это не шифрование и не “приватное хранение данных”, а именно commit‑reveal.
- Контракт использует pull-withdrawal и простую защиту от реэнтранси в `withdraw()`.

---

## Лицензия
MIT# time-caps
